{
  "name": "Python-8",
  "language": "py",
  "temperature": 0.8,
  "top_p": 0.95,
  "max_tokens": 1024,
  "prompt": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Calculate the maximum sum of values collected on two paths in an N x N grid.\n\n    This function utilizes dynamic programming to find two paths from the top-left corner to\n    the bottom-right corner of the grid which maximize the sum of the values collected. Each\n    value can be collected at most once, even if both paths pass through it.\n\n    Args:\n    - N (int): The size of the grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\n      the x-coordinate, y-coordinate, and value to be placed on the grid at that position.\n      The list is terminated by a tuple with all zeros.\n\n    Returns:\n    - int: The maximum sum of values collected on the two paths.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
  "tests": "def test_max_value_on_paths():\n    # Test case 1: Small grid with clear path\n    assert max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)]) == 3\n    \n    # Test case 2: Example provided in the problem statement\n    assert max_value_on_paths(8, [\n        (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n        (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n        (0, 0, 0)]) == 67\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_max_value_on_paths()",
  "stop_tokens": [
    "\ndef",
    "\n#",
    "\nif",
    "\nclass"
  ],
  "results": [
    {
      "program": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Calculate the maximum sum of values collected on two paths in an N x N grid.\n\n    This function utilizes dynamic programming to find two paths from the top-left corner to\n    the bottom-right corner of the grid which maximize the sum of the values collected. Each\n    value can be collected at most once, even if both paths pass through it.\n\n    Args:\n    - N (int): The size of the grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\n      the x-coordinate, y-coordinate, and value to be placed on the grid at that position.\n      The list is terminated by a tuple with all zeros.\n\n    Returns:\n    - int: The maximum sum of values collected on the two paths.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"\n    # Initialize the grid with a single path of zeroes\n    grid = [[[0, 0]] for _ in range(N)]\n\n    # Populate the grid with the values given by the user\n    for i, j, value in grid_values:\n        grid[i - 1][j - 1] = [[value, value], [0, 0]]\n\n    # Update the grid by iterating over the rows\n    for i in range(N):\n        # Update the grid by iterating over the columns\n        for j in range(N):\n            # Initialize a variable to store the maximum value from the left\n            left_max = 0\n\n            # If the left neighbor is not a wall, then take its maximum value\n            if grid[i][j - 1][0] != -1:\n                left_max = grid[i][j - 1][0]\n\n            # Initialize a variable to store the maximum value from the above\n            above_max = 0\n\n            # If the above neighbor is not a wall, then take its maximum value\n            if grid[i - 1][j][0] != -1:\n                above_max = grid[i - 1][j][0]\n\n            # If the current position is not a wall, then take its value\n            if grid[i][j][0] != -1:\n                current = grid[i][j][0]\n            else:\n                current = 0\n\n            # Calculate the maximum value from the current position\n            max_value = max(left_max, above_max, current)\n\n            # Set the maximum value for the current position\n            grid[i][j][0] = max_value\n\n            # Calculate the sum of values from the current position to the end\n            sum_values = max_value + grid[i][j][1]\n\n            # Set the sum of values for the current position\n            grid[i][j][1] = sum_values\n\n    # Return the maximum sum of values collected on the two paths\n    return grid[N - 1][N - 1][1]\ndef test_max_value_on_paths():\n    # Test case 1: Small grid with clear path\n    assert max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)]) == 3\n    \n    # Test case 2: Example provided in the problem statement\n    assert max_value_on_paths(8, [\n        (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n        (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n        (0, 0, 0)]) == 67\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_max_value_on_paths()",
      "timestamp": 1747069666,
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpig6_gcux.py\", line 87, in <module>\n    test_max_value_on_paths()\n  File \"/tmp/tmpig6_gcux.py\", line 76, in test_max_value_on_paths\n    assert max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)]) == 3\n  File \"/tmp/tmpig6_gcux.py\", line 34, in max_value_on_paths\n    grid[i - 1][j - 1] = [[value, value], [0, 0]]\nIndexError: list assignment index out of range\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}