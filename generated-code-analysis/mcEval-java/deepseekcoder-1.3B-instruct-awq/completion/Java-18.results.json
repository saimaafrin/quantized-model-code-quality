{
  "name": "Java-18",
  "language": "java",
  "temperature": 0.8,
  "top_p": 0.95,
  "max_tokens": 1024,
  "prompt": "import java.util.*;\n\nclass Problem {\n    /**\n     * Given a string s. You should re-order the string using the following algorithm:\n     * 1. Pick the smallest character from s and append it to the result.\n     * 2. Pick the smallest character from s which is greater than the last appended character to the result and append it.\n     * 3. Repeat step 2 until you cannot pick more characters.\n     * 4. Pick the largest character from s and append it to the result.\n     * 5. Pick the largest character from s which is smaller than the last appended character to the result and append it.\n     * 6. Repeat step 5 until you cannot pick more characters.\n     * 7. Repeat the steps from 1 to 6 until you pick all characters from s.\n     * In each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\n     * Return the result string after sorting s with this algorithm.\n     */\n    public String sortString(String s)",
  "tests": "    public static void main(String[] args) {\n        Problem solution = new Problem();\n\n        // Test the function with different test cases\n        assert solution.sortString(\"aaaabbbbcccc\").equals(\"abccbaabccba\");\n        assert solution.sortString(\"rat\").equals(\"art\");\n        assert solution.sortString(\"leetcode\").equals(\"cdelotee\");\n        System.out.println(\"All tests passed\");\n    }\n}",
  "stop_tokens": [],
  "results": [
    {
      "program": "import java.util.*;\n\nclass Problem {\n    /**\n     * Given a string s. You should re-order the string using the following algorithm:\n     * 1. Pick the smallest character from s and append it to the result.\n     * 2. Pick the smallest character from s which is greater than the last appended character to the result and append it.\n     * 3. Repeat step 2 until you cannot pick more characters.\n     * 4. Pick the largest character from s and append it to the result.\n     * 5. Pick the largest character from s which is smaller than the last appended character to the result and append it.\n     * 6. Repeat step 5 until you cannot pick more characters.\n     * 7. Repeat the steps from 1 to 6 until you pick all characters from s.\n     * In each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\n     * Return the result string after sorting s with this algorithm.\n     */\n    public String sortString(String s) {\n        Map<Character, Integer> map = new HashMap<>();\n        StringBuilder result = new StringBuilder();\n\n        for (char c : s.toCharArray()) {\n            map.put(c, map.getOrDefault(c, 0) + 1);\n        }\n\n        while (map.size() > 0) {\n            char minChar = '\\0';\n            for (char c : map.keySet()) {\n                if (minChar == '\\0') {\n                    minChar = c;\n                } else {\n                    if (map.get(c) < map.get(minChar)) {\n                        minChar = c;\n                   \n                    } else if (map.get(c) == map.get(minChar)) {\n                        if (c < minChar) {\n                            minChar = c;\n                        }\n                    }\n                }\n           \n            }\n            result.append(minChar);\n            map.put(minChar, map.get(minChar) - 1);\n            if (map.get(minChar) == 0) {\n                map.remove(minChar);\n            }\n\n            char maxChar = '\\0';\n            for (char c : map.keySet()) {\n                if (maxChar == '\\0') {\n                    maxChar = c;\n                } else {\n                    if (map.get(c) < map.get(maxChar)) {\n                        maxChar = c;\n                    } else if (map.get(c) == map.get(maxChar)) {\n                        if (c > maxChar) {\n                            maxChar = c;\n                        }\n                    }\n                }\n            }\n            result.append(maxChar);\n            map.put(maxChar, map.get(maxChar) - 1);\n            if (map.get(maxChar) == 0) {\n                map.remove(maxChar);\n            }\n        }\n        return result.toString();\n    }\n    public static void main(String[] args) {\n        Problem solution = new Problem();\n\n        // Test the function with different test cases\n        assert solution.sortString(\"aaaabbbbcccc\").equals(\"abccbaabccba\");\n        assert solution.sortString(\"rat\").equals(\"art\");\n        assert solution.sortString(\"leetcode\").equals(\"cdelotee\");\n        System.out.println(\"All tests passed\");\n    }\n}",
      "timestamp": 1741620720,
      "stdout": "",
      "stderr": "Exception in thread \"main\" java.lang.AssertionError\n\tat Problem.main(tmp3h49jzov.java:73)\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}